{
  "version": 3,
  "sources": ["../../../app/utils.ts"],
  "sourcesContent": ["import { useMatches } from \"@remix-run/react\";\nimport { useMemo } from \"react\";\n\nimport type { User } from \"~/models/user.server\";\n\nconst DEFAULT_REDIRECT = \"/\";\n\n/**\n * This should be used any time the redirect path is user-provided\n * (Like the query string on our login/signup pages). This avoids\n * open-redirect vulnerabilities.\n * @param {string} to The redirect destination\n * @param {string} defaultRedirect The redirect to use if the to is unsafe.\n */\nexport function safeRedirect(\n  to: FormDataEntryValue | string | null | undefined,\n  defaultRedirect: string = DEFAULT_REDIRECT\n) {\n  if (!to || typeof to !== \"string\") {\n    return defaultRedirect;\n  }\n\n  if (!to.startsWith(\"/\") || to.startsWith(\"//\")) {\n    return defaultRedirect;\n  }\n\n  return to;\n}\n\n/**\n * This base hook is used in other hooks to quickly search for specific data\n * across all loader data using useMatches.\n * @param {string} id The route id\n * @returns {JSON|undefined} The router data or undefined if not found\n */\nexport function useMatchesData(\n  id: string\n): Record<string, unknown> | undefined {\n  const matchingRoutes = useMatches();\n  const route = useMemo(\n    () => matchingRoutes.find((route) => route.id === id),\n    [matchingRoutes, id]\n  );\n  return route?.data;\n}\n\nfunction isUser(user: any): user is User {\n  return user && typeof user === \"object\" && typeof user.email === \"string\";\n}\n\nexport function useOptionalUser(): User | undefined {\n  const data = useMatchesData(\"root\");\n  if (!data || !isUser(data.user)) {\n    return undefined;\n  }\n  return data.user;\n}\n\nexport function useUser(): User {\n  const maybeUser = useOptionalUser();\n  if (!maybeUser) {\n    throw new Error(\n      \"No user found in root loader, but user is required by useUser. If user is optional, try useOptionalUser instead.\"\n    );\n  }\n  return maybeUser;\n}\n\nexport function validateEmail(email: unknown): email is string {\n  return typeof email === \"string\" && email.length > 3 && email.includes(\"@\");\n}\n\nexport function unifyServer() {\n  return process.env.UNIFY_HOST || \"http://127.0.0.1:5000\";\n}\n\nexport class ClientPipeline {\n  get query(): string {\n    return this._query;\n  }\n\n  private _query: string;\n\n  constructor(\n    public id: string,\n    public name: string,\n    public tables: string,\n    public operations: [],\n    public db_config: { \"db_backend\": string, \"db_host\": string, \"db_user\": string, \"db_password\": string },\n    public sort_col?: string,\n    public sort_desc?: number\n  ) {\n    this.id = id;\n    this.name = name;\n    this.tables = tables;\n    this.operations = operations;\n    this.sort_col = sort_col;\n    this.sort_desc = sort_desc;\n    this._query = \"\";\n    this.db_config = db_config; //'http://127.0.0.1:8123/'; //?query=SELECT%20%2A%20from%20tenant_default.github____org_repos%20FORMAT%20JSON''\n    this.db_config[\"db_host\"] = this.db_config[\"db_host\"].replace(\"localhost\", \"127.0.0.1\");\n  }\n\n  getTableList() {\n    if (this.tables && this.tables.length > 0) {\n      return this.tables.split(\",\");\n    } else {\n      return [];\n    }\n  }\n\n  getDbAuthHeaders() {\n    let headers = new Headers();\n    headers.set(\"Authorization\", \"Basic \" + btoa(this.db_config[\"db_user\"] + \":\" + this.db_config[\"db_password\"]));\n    return headers;\n  }\n\n  getServerUrl() {\n    let tables = this.getTableList();\n    if (tables.length > 0) {\n      let sort = \"\";\n      if (this.sort_col) {\n        sort = \" ORDER BY \" + this.sort_col;\n        if (this.sort_desc) {\n          sort += \" DESC\";\n        }\n      }\n      let query: string = \"SELECT * from tenant_default.\" + tables[0].replace(\".\", \"____\") + sort + \" LIMIT 1000 FORMAT JSON\";\n      this._query = query;\n      return new URL(`http://${this.db_config[\"db_host\"]}?query=${encodeURIComponent(query)}`);\n    } else {\n      return null;\n    }\n  }\n}\n\nexport function classNames(...classes: string[]) {\n  return classes.filter(Boolean).join(\" \");\n}"],
  "mappings": ";;;;;;;;;AACA,IAAAA,gBAAwB;AAkCjB,SAAS,eACd,IACqC;AACrC,QAAM,iBAAiB,WAAW;AAClC,QAAM,YAAQ;AAAA,IACZ,MAAM,eAAe,KAAK,CAACC,WAAUA,OAAM,OAAO,EAAE;AAAA,IACpD,CAAC,gBAAgB,EAAE;AAAA,EACrB;AACA,SAAO,+BAAO;AAChB;AAEA,SAAS,OAAO,MAAyB;AACvC,SAAO,QAAQ,OAAO,SAAS,YAAY,OAAO,KAAK,UAAU;AACnE;AAEO,SAAS,kBAAoC;AAClD,QAAM,OAAO,eAAe,MAAM;AAClC,MAAI,CAAC,QAAQ,CAAC,OAAO,KAAK,IAAI,GAAG;AAC/B,WAAO;AAAA,EACT;AACA,SAAO,KAAK;AACd;AAEO,SAAS,UAAgB;AAC9B,QAAM,YAAY,gBAAgB;AAClC,MAAI,CAAC,WAAW;AACd,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAUO,IAAM,iBAAN,MAAqB;AAAA,EAO1B,YACS,IACA,MACA,QACA,YACA,WACA,UACA,WACP;AAPO;AACA;AACA;AACA;AACA;AACA;AACA;AAEP,SAAK,KAAK;AACV,SAAK,OAAO;AACZ,SAAK,SAAS;AACd,SAAK,aAAa;AAClB,SAAK,WAAW;AAChB,SAAK,YAAY;AACjB,SAAK,SAAS;AACd,SAAK,YAAY;AACjB,SAAK,UAAU,aAAa,KAAK,UAAU,WAAW,QAAQ,aAAa,WAAW;AAAA,EACxF;AAAA,EAxBA,IAAI,QAAgB;AAClB,WAAO,KAAK;AAAA,EACd;AAAA,EAwBA,eAAe;AACb,QAAI,KAAK,UAAU,KAAK,OAAO,SAAS,GAAG;AACzC,aAAO,KAAK,OAAO,MAAM,GAAG;AAAA,IAC9B,OAAO;AACL,aAAO,CAAC;AAAA,IACV;AAAA,EACF;AAAA,EAEA,mBAAmB;AACjB,QAAI,UAAU,IAAI,QAAQ;AAC1B,YAAQ,IAAI,iBAAiB,WAAW,KAAK,KAAK,UAAU,aAAa,MAAM,KAAK,UAAU,cAAc,CAAC;AAC7G,WAAO;AAAA,EACT;AAAA,EAEA,eAAe;AACb,QAAI,SAAS,KAAK,aAAa;AAC/B,QAAI,OAAO,SAAS,GAAG;AACrB,UAAI,OAAO;AACX,UAAI,KAAK,UAAU;AACjB,eAAO,eAAe,KAAK;AAC3B,YAAI,KAAK,WAAW;AAClB,kBAAQ;AAAA,QACV;AAAA,MACF;AACA,UAAI,QAAgB,kCAAkC,OAAO,GAAG,QAAQ,KAAK,MAAM,IAAI,OAAO;AAC9F,WAAK,SAAS;AACd,aAAO,IAAI,IAAI,UAAU,KAAK,UAAU,oBAAoB,mBAAmB,KAAK,GAAG;AAAA,IACzF,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAEO,SAAS,cAAc,SAAmB;AAC/C,SAAO,QAAQ,OAAO,OAAO,EAAE,KAAK,GAAG;AACzC;",
  "names": ["import_react", "route"]
}
